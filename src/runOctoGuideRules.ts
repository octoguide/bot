import * as core from "@actions/core";
import { octokitFromAuth } from "octokit-from-auth";

import type { EntityActor } from "./actors/types.js";
import type { Entity } from "./types/entities.js";
import type { RuleReport } from "./types/reports.js";
import type { RuleContext } from "./types/rules.js";
import type { Settings } from "./types/settings.js";

import { createActor } from "./actors/createActor.js";
import { isRuleSkippedForEntity } from "./execution/isRuleSkippedForEntity.js";
import { mergeRuleOptions } from "./execution/mergeRuleOptions.js";
import { runRuleOnEntity } from "./execution/runRuleOnEntity.js";
import { allRules } from "./rules/all.js";
import { configs } from "./rules/configs.js";

/**
 * Settings for running {@link runOctoGuideRules}.
 * Only `entity` is required.
 * @example
 * import { runOctoGuideRules } from "octoguide";
 *
 * // Using a URL string - will fetch data from GitHub API
 * await runOctoGuideRules({
 *   auth: "ghp_...",
 *   entity: "https://github.com/OctoGuide/bot/issues/19",
 * });
 *
 * // Using pre-existing Entity data - avoids API calls
 * const existingEntity = {
 *   data: { },
 *   number: 19,
 *   type: "issue",
 * };
 *
 * await runOctoGuideRules({
 *   auth: "ghp_...",
 *   entity: existingEntity,
 * });
 */
export interface RunOctoGuideRulesOptions {
	/**
	 * GitHub authentication token.
	 * If not provided, retrieved with `get-github-auth-token`.
	 */
	auth?: string;

	/**
	 * GitHub entity to run rules on. Can be either:
	 * - A string URL (e.g., `"https://github.com/owner/repo/issues/123"`) - will fetch entity data via GitHub API
	 * - An `Entity` object with pre-fetched data - avoids additional API calls when data is already available
	 */
	entity: Entity | string;

	/**
	 * Settings for the run, including rules to enable.
	 */
	settings: Settings;
}

/**
 * Returned data from running {@link runOctoGuideRules}.
 * @example
 * const { entity, reports } = await runOctoGuideRules({
 *   entity: "https://github.com/OctoGuide/bot/issues/19",
 * });
 *
 * console.log("Entity URL:", entity.data.html_url);
 * console.log("Received reports:", reports);
 */
export interface RunOctoGuideRulesResult {
	/**
	 * @internal
	 */
	actor: EntityActor;

	/**
	 * The entity that was scanned.
	 */
	entity: Entity;

	/**
	 * Any reports generated by the rules.
	 */
	reports: RuleReport[];
}

/**
 * Runs OctoGuide's rules to generate a list of reports for a GitHub entity.
 * The entity can be provided as either a URL string (which will be fetched from the GitHub API) or pre-existing entity data.
 *
 * Takes in a single parameter of type {@link RunOctoGuideRulesOptions}.
 * Returns a {@link RunOctoGuideRulesResult}.
 * @example
 * import { runOctoGuideRules } from "octoguide";
 *
 * const { reports } = await runOctoGuideRules({
 *   entity: "https://github.com/OctoGuide/bot/issues/19",
 * });
 *
 * console.log("Received reports:", reports);
 * @param options Configuration object
 * @param options.auth GitHub authentication token or Octokit instance
 * @param options.entity Entity input (URL string or entity data object)
 * @param options.settings OctoGuide configuration settings including rules and comments
 * @returns Promise resolving to results with actor, entity data, and rule reports
 */
export async function runOctoGuideRules({
	auth,
	entity: entityInput,
	settings,
}: RunOctoGuideRulesOptions): Promise<RunOctoGuideRulesResult> {
	// TODO: There's no need to create a full *writing* actor here;
	// runOctoGuide only reads entities and runs rules on them.
	// This area of authentication and actor resolution should split into:
	// 1. Entity data & type resolution: read-only allowed
	// 2. Using that to create the equivalent actor: requires writing
	// ...where only 1. is needed for runOctoGuide.
	// https://github.com/OctoGuide/bot/issues/56
	const octokit = await octokitFromAuth({ auth });

	const url =
		typeof entityInput === "string" ? entityInput : entityInput.data.html_url;

	if (typeof url !== "string") {
		throw new Error("Entity data's html_url is not a string.");
	}

	const { actor, locator } = createActor(octokit, url);
	if (!actor) {
		throw new Error("Could not resolve GitHub entity actor.");
	}

	const entity =
		typeof entityInput === "string"
			? ({
					data: await actor.getData(),
					...actor.metadata,
				} as Entity)
			: entityInput;

	if (core.isDebug()) {
		core.debug(`Full entity: ${JSON.stringify(entity, null, 2)}`);
	}

	const reports: RuleReport[] = [];

	const config = settings.config ?? "recommended";
	const configRuleNames = Object.values(configs[config]).map(
		(rule) => rule.about.name,
	);
	const ruleOverrides = settings.rules ?? {};

	const enabledRules = allRules.filter((rule) => {
		const ruleName = rule.about.name;

		if (ruleName in ruleOverrides) {
			return ruleOverrides[ruleName];
		}

		return configRuleNames.includes(ruleName);
	});

	await Promise.all(
		enabledRules.map(async (rule) => {
			// TODO: merge with parent options
			const options = mergeRuleOptions(
				settings.baseOptions,
				ruleOverrides[rule.about.name],
			);

			const context: RuleContext = {
				locator,
				octokit,
				options: typeof options === "object" ? options : undefined,
				report(data) {
					reports.push({
						about: rule.about,
						data,
					});
				},
			};

			if (!isRuleSkippedForEntity(entity, options, rule)) {
				await runRuleOnEntity(context, rule, entity);
			}
		}),
	);

	return { actor, entity, reports };
}
