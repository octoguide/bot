import * as core from "@actions/core";
import { octokitFromAuth } from "octokit-from-auth";

import type { EntityActor } from "./actors/types.js";
import type { Entity } from "./types/entities.js";
import type { RuleReport } from "./types/reports.js";
import type { RuleContext } from "./types/rules.js";
import type { Settings } from "./types/settings.js";

import { createActor } from "./actors/createActor.js";
import { runRuleOnEntity } from "./execution/runRuleOnEntity.js";
import { allRules } from "./rules/all.js";
import { configs } from "./rules/configs.js";

/**
 * Settings for running {@link runOctoGuideRules}.
 */
export interface RunOctoGuideRulesOptions {
	/**
	 * GitHub authentication token, to override process.env.GH_TOKEN.
	 */
	auth?: string;

	/**
	 * GitHub entity to scan. Can be either:
	 * - A string URL (e.g., "https://github.com/owner/repo/issues/123") - will fetch entity data via API
	 * - An Entity object with pre-fetched data - avoids additional API calls when data is already available
	 */
	entity: Entity | string;

	/**
	 * Settings for the run, including rules to enable.
	 */
	settings?: Settings;
}

/**
 * Result from running {@link runOctoGuideRules}.
 */
export interface RunOctoGuideRulesResult {
	/**
	 * @internal
	 */
	actor: EntityActor;

	/**
	 * The resolved entity that was scanned.
	 */
	entity: Entity;

	/**
	 * Any reports generated by rules for the entity.
	 */
	reports: RuleReport[];
}

/**
 * Runs OctoGuide's rules to generate a list of reports for a GitHub entity.
 * @param options Configuration object
 * @param options.auth GitHub authentication token or Octokit instance
 * @param options.entity Entity input (URL string or entity data object)
 * @param options.settings OctoGuide configuration settings including rules and comments
 * @returns Promise resolving to results with actor, entity data, and rule reports
 */
export async function runOctoGuideRules({
	auth,
	entity: entityInput,
	settings,
}: RunOctoGuideRulesOptions): Promise<RunOctoGuideRulesResult> {
	// TODO: There's no need to create a full *writing* actor here;
	// runOctoGuide only reads entities and runs rules on them.
	// This area of authentication and actor resolution should split into:
	// 1. Entity data & type resolution: read-only allowed
	// 2. Using that to create the equivalent actor: requires writing
	// ...where only 1. is needed for runOctoGuide.
	// https://github.com/OctoGuide/bot/issues/56
	const octokit = await octokitFromAuth({ auth });

	const url =
		typeof entityInput === "string" ? entityInput : entityInput.data.html_url;

	if (typeof url !== "string") {
		throw new Error("Entity data's html_url is not a string.");
	}

	const { actor, locator } = createActor(octokit, url);
	if (!actor) {
		throw new Error("Could not resolve GitHub entity actor.");
	}

	const entity =
		typeof entityInput === "string"
			? ({
					data: await actor.getData(),
					...actor.metadata,
				} as Entity)
			: entityInput;

	if (core.isDebug()) {
		core.debug(`Full entity: ${JSON.stringify(entity, null, 2)}`);
	}

	const reports: RuleReport[] = [];

	const config = settings?.config ?? "recommended";
	const configRuleNames = Object.values(configs[config]).map(
		(rule) => rule.about.name,
	);
	const ruleOverrides = settings?.rules ?? {};

	const enabledRules = allRules.filter((rule) => {
		const ruleName = rule.about.name;

		if (ruleName in ruleOverrides) {
			return ruleOverrides[ruleName];
		}

		return configRuleNames.includes(ruleName);
	});

	console.log({ config, configRuleNames, enabledRules, ruleOverrides });

	await Promise.all(
		enabledRules.map(async (rule) => {
			const context: RuleContext = {
				locator,
				octokit,
				report(data) {
					reports.push({
						about: rule.about,
						data,
					});
				},
			};

			await runRuleOnEntity(context, rule, entity);
		}),
	);

	return { actor, entity, reports };
}
